---
output:
  md_document:
    variant: html
---

# Purpose

Purpose of this work folder.

Ideally store a minimum working example data set in data folder.

Add binary files in bin, and closed R functions in code. Human Readable settings files (e.g. csv) should be placed in settings/


```{r, echo=FALSE}

rm(list = ls()) # Clean your environment:
gc() # garbage collection - It can be useful to call gc after a large object has been removed, as this may prompt R to return memory to the operating system.
library(tidyverse)
list.files('code/', full.names = T, recursive = T) %>% .[grepl('.R', .)] %>% as.list() %>% walk(~source(.))

# Installing and/or loading packages

pacman::p_load("tidyverse","fmxdat", "dplyr", "rmsfuns", "PerformanceAnalytics", "tbl2xts", "xts", "rportfolios", "Texevier", "kableExtra", "ggplot2", "extrafont", "devtools")

```


# Question 1

NOTE TO SELF --> FIGURE OUT HOW TO LET A FEW ACTIVE FUNDS REPRESENT THE ENTIRE SAMPLE, IN ORDER TO COMPARE. IE, EW PORTF? PCA? CLUSTER?


```{r, Loading Data}

ASISA <- read_rds("data/ASISA.rds") # ASISA Active Managers. Notice that there are 227 different actively managed funds.

                                    # Monthly observations, 2002-11-30 to 2022-10-31

BM <- read_rds("data/Capped_SWIX.rds") # Benchmark: Capped Swix. Monthly observations, 1999-12-31 to 2022-10-31

AI_Fund <- read_rds("data/AI_Max_Fund.rds") # My Systematic AI Fund. Monthly observations, 2003-01-31 to 2022-10-31

```




```{r}


df <- left_join(BM |> pivot_wider(names_from = "Tickers", values_from = "Returns") , ASISA |> pivot_wider(names_from = "Name", values_from = "Returns"), by= "date") |> left_join(AI_Fund |> pivot_wider(names_from = "Tickers", values_from = "Returns"), by ="date") |> pivot_longer(cols = -date ,names_to = "Name", values_to = "Returns") 


p <- df |> arrange(date) |> filter(Name == c("Our_Fund", "J433")) |> 
    
    ggplot() + 
  
  geom_line(aes(date, Returns, color = Name), size = 0.4, alpha = 0.7) + 
  
  fmxdat::theme_fmx(title.size = fmxdat::ggpts(30), 
                    subtitle.size = fmxdat::ggpts(28),
                    caption.size = fmxdat::ggpts(25),
                    CustomCaption = F) + 
  
  fmxdat::fmx_cols() + 
  
  labs(x = "", y = "Cumulative Returns", caption = "Note:\nCalculation own",
       title = "Illustrating fmxdat Auxilliary functions for ggplot",
       subtitle = "If not subtitle, make blank and Subtitle size small to make a gap\nbetween plot and Title. Test this yourself")
  
# Finplot now adds finishing touches easily:

  fmxdat::finplot(p, x.vert = T, x.date.type = "%Y", x.date.dist = "2 years")

```



# Question 2


```{r, Data Import}

SA_bonds <- read_rds("data/SA_Bonds.rds")
BE_Infl <- read_rds("data/BE_Infl.rds")
bonds_2y <- read_rds("data/bonds_2y.rds")
bonds_10y <- read_rds("data/bonds_10y.rds")
usdzar <- read_rds("data/usdzar.rds")
ZA_Infl <- read_rds("data/ZA_Infl.rds")
IV <- read_rds("data/IV.rds")

```

```{r, Global Bond Yield Spreads Data Wrangling}

Countries_to_compare <- c("Germany", "ZA", "US", "CHINA", "Japan", "Brazil")

bonds_10y_adj <- bonds_10y |> pivot_wider(names_from = "Name", values_from = "Bond_10Yr") |> 
    
    left_join(SA_bonds |> select(c(date, ZA_10Yr)), by="date") |> 
    
    pivot_longer(cols = -date, names_to = "Name", values_to = "Bond_10Yr")|> 
    
    mutate(Name = gsub("_10Yr", "", Name)) |> 
    
    filter((Name %in% Countries_to_compare))  # Only filter the desired countries

# Upon initial attempt to format bonds_2y, I realised there is a duplicate entry, identified by the following 

duplicate_entries_identification <- bonds_2y %>%
                                    dplyr::group_by(date, Name) %>%
                                    dplyr::summarise(n = dplyr::n(), .groups = "drop") %>%
                                    dplyr::filter(n > 1L)

# Since the duplicate entry is "Chile_2yr", I remove Chile in order to pivot_wider. 

bonds_2y_adj <- bonds_2y |> filter(!(Name %in% c("Chile_2yr"))) |>  # remove chile
    
    pivot_wider(names_from = "Name", values_from = "Bond_2Yr") |> 
    
    left_join(SA_bonds |> select(c(date, ZA_2Yr)), by="date") |> 
    
    pivot_longer(cols = -date, names_to = "Name", values_to = "Bond_2Yr") |> 
    
    mutate(Name = gsub("_2yr", "", Name)) |> mutate(Name = gsub("_2Yr", "", Name)) |> 
    
    filter(Name %in% Countries_to_compare) 

# Now I proceed to merge the 2Yr and 10Yr global yields and their spreads in one tbl

Global_bonds_data <- inner_join(bonds_2y_adj, bonds_10y_adj, by= c("date", "Name")) |> 
    
    mutate(Spread = Bond_10Yr - Bond_2Yr)

```

```{r, Global Bond Yield Spreads Plot}

Global_bonds_plot <-    Global_bonds_data |> select(date,Name ,Spread) |> 
    
    ggplot() + 
  
  geom_line(aes(date, Spread , color = Name), size = 0.8, alpha = 0.7) +
  
   fmxdat::theme_fmx(title.size = fmxdat::ggpts(30), 
                    subtitle.size = fmxdat::ggpts(0),
                    caption.size = fmxdat::ggpts(25),
                    CustomCaption = T) + 
    
  fmxdat::fmx_cols() + 
  
  labs(x = "", y = "Yield Spread (%)", caption = "Note:\nCalculation own",
       title = "Global Bond Market Yield Spreads",
       subtitle = "")
  
# Finplot for finishing touches:

fmxdat::finplot(Global_bonds_plot, x.vert = T, x.date.type = "%Y", x.date.dist = "2 years", darkcol = F)




```

```{r, US and SA Real Yield Spread}

SA_Bonds_Plot <- Global_bonds_data |> filter(Name %in% c("ZA")) |> left_join(usdzar |> select(-Name), by = "date") |> 
    
    rename( R_USD = Price) |> pivot_longer(cols = -c(date, Name), names_to = "Description", values_to = "Values") |> 
    
    ggplot() + 
  
  geom_line(aes(date, Values , color = Description), size = 0.8, alpha = 0.7) +
  
   fmxdat::theme_fmx(title.size = fmxdat::ggpts(30), 
                    subtitle.size = fmxdat::ggpts(0),
                    caption.size = fmxdat::ggpts(25),
                    CustomCaption = T) + 
    
  fmxdat::fmx_cols() + 
  
  labs(x = "", y = "", caption = "Note:\nCalculation own",
       title = "SA Bond Yields, Spread, and R/USD Exchange Rate",
       subtitle = "")
    
# Finplot for finishing touches:

fmxdat::finplot(SA_Bonds_Plot, x.vert = T, x.date.type = "%Y", x.date.dist = "2 years", darkcol = F)

```

```{r, Statistical Tables Pre and Post GFC US and SA}

# Partition ZA and US yield spread data into post and pre GFC and convert to xts

pre_GFC_xts <- Global_bonds_data|> filter(Name %in% c("ZA", "US")) |> select(date, Name, Spread) |> 
     
    filter(date <= lubridate::ymd(20081031)) |>  
    
    filter(date >= lubridate::ymd(19991206)) |>  # Start from ZA's first observation
    
    tbl_xts(cols_to_xts = Spread, spread_by = Name) 
    
post_GFC_xts <- Global_bonds_data|> filter(Name %in% c("ZA", "US")) |> select(date,Name ,Spread) |> 
     
    filter(date >= lubridate::ymd(20081031)) |> tbl_xts(cols_to_xts = Spread, spread_by = Name) 

# Use performance analytics package for statistical table

table_pre_GFC <- PerformanceAnalytics::table.Stats(pre_GFC_xts, ci=0.95, digits = 2)

table_post_GFC <- PerformanceAnalytics::table.Stats(post_GFC_xts, ci=0.95, digits = 2)

# Only select the desired stats

table_pre_GFC <- table_pre_GFC[c(3,6,9,10,11,12,14,15,16),] 
table_post_GFC <- table_post_GFC[c(3,6,9,10,11,12,14,15,16),] 

# Finally summarise neatly in a table using kable

final_stats_table <- 
    
    table_pre_GFC |>  data.frame() |>  tibble::rownames_to_column()|> 
    left_join(table_post_GFC|>  data.frame() |>  tibble::rownames_to_column(), by = "rowname" ) |> 
    rename(Description = rowname) |> 
    
    knitr::kable(col.names = c("Description",
                           "SA",
                           "US",
                           "SA", "US")) |> kable_classic(full_width = F) |> 
    
    add_header_above(c(" " = 1, "Pre GFC" = 2, "Post GFC" = 2))



final_stats_table

```

```{r, SA Break-Even Inflation Yield}

# Break-even inflation is the difference between the nominal yield on a fixed-rate investment and the real yield (fixed spread) on an inflation-linked investment of similar maturity and credit quality. If inflation averages more than the break-even, the inflation-linked investment will outperform the fixed-rate.

# Find the monthly values of BE Infl Yiels to compare to monthly inflation data 

BE_Infl_adj <- BE_Infl |> mutate(YearMonth = format(date, "%Y-%m")) |> 
    
    group_by(YearMonth) |> filter(date == last(date)) |> 
    
    ungroup() |> rename(BEI = Price)|> select(YearMonth, BEI)

# Notice that the number of days withing the BE inflation set is incorrect, so I rather use YearMonth as common column, 
# And then utilise the dateconverter command. 

BEI_infl_plot <- ZA_Infl |> mutate(YearMonth = format(date, "%Y-%m") ) |> 
    
    select(YearMonth, Price) |> rename(Inflation = Price) |> 
    
    right_join(BE_Infl_adj, by = "YearMonth") |> 
    
    mutate(date = dateconverter(as.Date("2012-05-01"), as.Date("2021-10-29"), "calendarEOM")) |> 
    
    select(-YearMonth) |> 
    
    pivot_longer(cols = -date, names_to = "Name", values_to = "Values") |> 
    
     ggplot() + 
  
  geom_line(aes(date, Values , color = Name), size = 0.8, alpha = 0.7) +
  
   fmxdat::theme_fmx(title.size = fmxdat::ggpts(30), 
                    subtitle.size = fmxdat::ggpts(0),
                    caption.size = fmxdat::ggpts(25),
                    CustomCaption = T) + 
    
  fmxdat::fmx_cols() + 
  
  labs(x = "", y = "%", caption = "Note:\nCalculation own",
       title = "SA Break-Even Inflation Yield Versus Average Inflation Rate",
       subtitle = "")

# Finplot for finishing touches:

fmxdat::finplot(BEI_infl_plot, x.vert = T, x.date.type = "%Y", x.date.dist = "2 years", darkcol = F)

```




# Question 3 




```{r, Data import}

T40 <- read_rds("data/T40.rds") # There are 92 stocks in this tbl

RebDays <- read_rds("data/Rebalance_days.rds")

Capped_SWIX <- read_rds("data/Capped_SWIX.rds") # This is the Monthly Capped and Weighted Portf Returns for SWIX Index (J433)

# I first shrink the dataframe to include only what in needed

T40_a <- T40 |> select(-Short.Name) |> 
    
    mutate(Tickers = gsub(" SJ Equity", "", Tickers))  # Remove clutter in Tickers names

```

```{r, ALSI and SWIX wieghted port returns by hand}

# I generate a tbl calculating both Indexes weighted returns by hand

df_Port_ret <- T40_a |> 
    
    mutate(J400 = coalesce(J400, 0)) |> 
    
    mutate(J400 = coalesce(J400, 0)) |> 
    
    mutate(ALSI_wret = Return*J200) |> 
    
    mutate(SWIX_wret = Return*J400) |> 
    
    arrange(date) |> 
    
    group_by(date) |> 
    
    mutate(ALSI_pret = sum(ALSI_wret)) |> 
    
    mutate(SWIX_pret = sum(SWIX_wret)) 
    
```



```{r, ALSI and SWIX weighted portfoio returns using Safe_returns}


# Lets calculate the weighted portfolio daily return for ALSI and SWIX using Safe_Returns to verify my by hand calculation

Wghts_ALSI_xts <- T40_a |> select(date, Tickers , J200) |> tbl_xts(cols_to_xts = J200, spread_by = Tickers)

Wghts_SWIX_xts <- T40_a |> select(date, Tickers , J400) |> tbl_xts(cols_to_xts = J400, spread_by = Tickers)

Returns_xts <- T40_a |> select(date, Tickers , Return) |> tbl_xts(cols_to_xts = Return, spread_by = Tickers)

# Set NA's to null to use PA's Safe_returns.Portfolio command

Wghts_ALSI_xts[is.na(Wghts_ALSI_xts)] <- 0
Wghts_SWIX_xts[is.na(Wghts_SWIX_xts)] <- 0
Returns_xts[is.na(Returns_xts)] <- 0

# Now I calculate the weighed (uncapped) portfolio returns

Port_Ret_ALSI <- rmsfuns::Safe_Return.portfolio(R = Returns_xts, weights = Wghts_ALSI_xts, lag_weights = T) |> 
    
                 xts_tbl() |> rename(ALSI_Ret = portfolio.returns)

Port_Ret_SWIX <- rmsfuns::Safe_Return.portfolio(R = Returns_xts, weights = Wghts_SWIX_xts, lag_weights = T) |> 
    
                 xts_tbl() |> rename(SWIX_Ret = portfolio.returns)

# Now I combine the above two weighted portfolio returns

Merged_Port_Ret <- inner_join(Port_Ret_ALSI, Port_Ret_SWIX, by= "date")

# I verify that my by hand calc and the Safe_return calc is the same:
# df_Port_ret |> select(date, ALSI_pret, SWIX_pret) |> group_by(date, ALSI_pret, SWIX_pret ) |> summarise()
# Happy ---> They are the same

```

```{r, Portfolios cumulative returns}

# Now I proceed to calculate the Portfolios' cumulative return and plot it

Cum_ret <- Merged_Port_Ret |> arrange(date) |> 
    
    mutate(across(.cols = -date, .fns = ~cumprod(1 + .))) |> 
    
    mutate(across(.cols = -date, .fns = ~./first(.))) |> # Start at 1
    
    rename(ALSI = ALSI_Ret, SWIX= SWIX_Ret) |> 
    
    pivot_longer(cols=-date, names_to = "Index", values_to = "Cumret")
    
# And finally the plot

Indexes_Cum_ret_plot <-    Cum_ret |> 
       
       ggplot() + 
  
  geom_line(aes(date, Cumret , color = Index), size = 0.6, alpha = 0.7) +
  
   fmxdat::theme_fmx(title.size = fmxdat::ggpts(30), 
                    subtitle.size = fmxdat::ggpts(0),
                    caption.size = fmxdat::ggpts(25),
                    CustomCaption = T) + 
    
  fmxdat::fmx_cols() + 
  
  labs(x = "", y = "%", caption = "Note:\nCalculation own",
       title = "Cumulative Returns of ALSI and SWIX Indexes",
       subtitle = "")

# Finplot for finishing touches:

fmxdat::finplot(Indexes_Cum_ret_plot, x.vert = T, x.date.type = "%Y", x.date.dist = "1 year", darkcol = T)

```

```{r, Portfolio Returns subdivided into Market Cap's Contributions}

# I now create the final tbl that includes the weighted return contribition of each sector  to the overall weighted portfolio return (daily) 

df_Port_ret_final <- df_Port_ret |> arrange(date) |> 
    
    group_by(date, Sector) |>       # Group by Market Cap to calc each category's contr to wieghted portf return
    
    mutate(ALSI_wght_sector = coalesce(J400, 0)) |> # Make NA's 0 to use PA later
    
    mutate(SWIX_wght_sector = coalesce(J200, 0)) |>
    
    mutate(ALSI_wret = coalesce(ALSI_wret, 0)) |> 
    
    mutate(SWIX_wret = coalesce(SWIX_wret, 0)) |>
    
    mutate(ALSI_ret_sector = sum(ALSI_wret, na.rm = T)) |>  # The weight-contribution of each sector on each day
    
    mutate(SWIX_ret_sector = sum(SWIX_wret, na.rm = T)) |>

    mutate(ALSI_wght_sector = sum(J400, na.rm = T)) |>  # The weighted return contribution of each sector on each day
    
    mutate(SWIX_wght_sector = sum(J200, na.rm = T)) |>
    
    ungroup()

ALSI_wght_sector <-  df_Port_ret_final |> select(date, Sector ,ALSI_wght_sector) |> group_by(Sector) |> unique() |> 
    tbl_xts(cols_to_xts = ALSI_wght_sector, spread_by = Sector)

SWIX_wght_sector <- df_Port_ret_final |> select(date, Sector ,SWIX_wght_sector) |> group_by(Sector) |> unique() |> 
    tbl_xts(cols_to_xts = SWIX_wght_sector, spread_by = Sector)

ALSI_ret_sector <- df_Port_ret_final |> select(date, Sector ,ALSI_ret_sector) |> group_by(Sector) |> unique() |> 
    tbl_xts(cols_to_xts = ALSI_ret_sector, spread_by = Sector)

SWIX_ret_sector <- df_Port_ret_final |> select(date, Sector ,SWIX_ret_sector) |> group_by(Sector) |> unique() |> 
    tbl_xts(cols_to_xts = SWIX_ret_sector, spread_by = Sector)



 ALSI_RetPort_sector <- 
      rmsfuns::Safe_Return.portfolio(ALSI_ret_sector, 
                                     
                       weights = ALSI_wght_sector, lag_weights = TRUE,
                       
                       verbose = TRUE, contribution = TRUE, 
                       
                       value = 1000, geometric = TRUE) 

 SWIX_RetPort_sector <- 
      rmsfuns::Safe_Return.portfolio(SWIX_ret_sector, 
                                     
                       weights = SWIX_wght_sector, lag_weights = TRUE,
                       
                       verbose = TRUE, contribution = TRUE, 
                       
                       value = 1000, geometric = TRUE)
    

 ALSI_RetPort_sector$BOP.Weight  %>% .[endpoints(.,'months')] %>% chart.StackedBar()
 
  SWIX_RetPort_sector$BOP.Weight  %>% .[endpoints(.,'months')] %>% chart.StackedBar()

  ALSI_RetPort_sector$contribution |> chart.CumReturns(legend.loc = "bottom")
  
  SWIX_RetPort_sector$contribution |> chart.CumReturns(legend.loc = "bottom")
 
```

```{r, Rebalance days}

# I firt pull the effective rebalance dates

Rebalance_Days <-RebDays |> filter(Date_Type %in% c("Effective Date")) |> pull(date)
    
# And now for both Indexes I create a capped weights tbl for rebalancing purposes

rebalance_col_ALSI <- T40_a |> 
    
    filter(date %in% Rebalance_Days) |> 
    
    select(date, Tickers, J200) |> 
    
    rename(weight = J200) |> 
    
    mutate(RebalanceTime = format(date, "%Y_%b")) |> 
    
    mutate(weight= coalesce(weight, 0))
    
 rebalance_col_SWIX <- T40_a |> 
    
    filter(date %in% Rebalance_Days) |> 
    
    select(date, Tickers, J400) |> 
     
     rename(weight = J400) |> 
     
     mutate(RebalanceTime = format(date, "%Y_%b")) |> 
     
      mutate(weight= coalesce(weight, 0))
    
```


```{r, lets apply capping to the indexes}

Proportional_Cap_Foo <- function(df_Cons, W_Cap = 0.08){
  
  # Let's require a specific form from the user... Alerting when it does not adhere this form
  if( !"weight" %in% names(df_Cons)) stop("... for Calc capping to work, provide weight column called 'weight'")
  
  if( !"date" %in% names(df_Cons)) stop("... for Calc capping to work, provide date column called 'date'")
  
  if( !"Tickers" %in% names(df_Cons)) stop("... for Calc capping to work, provide id column called 'Tickers'")

  # First identify the cap breachers...
  Breachers <- 
    df_Cons %>% filter(weight > W_Cap) %>% pull(Tickers)
  
  # Now keep track of breachers, and add to it to ensure they remain at 10%:
  if(length(Breachers) > 0) {
    
    while( df_Cons %>% filter(weight > W_Cap) %>% nrow() > 0 ) {
      
      
      df_Cons <-
        
        bind_rows(
          
          df_Cons %>% filter(Tickers %in% Breachers) %>% mutate(weight = W_Cap),
          
          df_Cons %>% filter(!Tickers %in% Breachers) %>% 
            mutate(weight = (weight / sum(weight, na.rm=T)) * (1-length(Breachers)*W_Cap) )
          
        )
      
      Breachers <- c(Breachers, df_Cons %>% filter(weight > W_Cap) %>% pull(Tickers))
      
    }

    if( sum(df_Cons$weight, na.rm=T) > 1.001 | sum(df_Cons$weight, na.rm=T) < 0.999 | max(df_Cons$weight, na.rm = T) > W_Cap) {
      
      stop( glue::glue("For the Generic weight trimming function used: the weight trimming causes non unit 
      summation of weights for date: {unique(df_Cons$date)}...\n
      The restriction could be too low or some dates have extreme concentrations...") )
      
    }
    
  } else {
    
  }
  
  df_Cons
  
  }
  

# Now, to map this across all the dates, I purrr::map_df 
Capped_ALSI_10 <- 
    
    rebalance_col_ALSI |> 

    group_split(RebalanceTime) |> 
    
    map_df(~Proportional_Cap_Foo(., W_Cap = 0.1) ) |>  select(-RebalanceTime)
  
# Now I do the same for a 6% cap:

Capped_ALSI_6 <- 
    
    rebalance_col_ALSI |> 

    group_split(RebalanceTime) |> 
    
    map_df(~Proportional_Cap_Foo(., W_Cap = 0.06) ) |>  select(-RebalanceTime)

Capped_SWIX_10 <- 
    
    rebalance_col_ALSI |> 

    group_split(RebalanceTime) |> 
    
    map_df(~Proportional_Cap_Foo(., W_Cap = 0.1) ) |>  select(-RebalanceTime)
  
Capped_SWIX_6 <- 
    
    rebalance_col_ALSI |> 

    group_split(RebalanceTime) |> 
    
    map_df(~Proportional_Cap_Foo(., W_Cap = 0.06) ) |>  select(-RebalanceTime)

# # Testing if the max weight is correct for all 4 tbl above

Capped_ALSI_10 %>% pull(weight) %>% max(.) 
Capped_ALSI_6 %>% pull(weight) %>% max(.) 
Capped_SWIX_10 %>% pull(weight) %>% max(.) 
Capped_SWIX_6 %>% pull(weight) %>% max(.) # Success!!

```


```{r, Newly capped index weighted returns}

####For ALSI capped at 10%#####

wghts_ALSI_10 <- 
  Capped_ALSI_10 %>% 
  tbl_xts(cols_to_xts = weight, spread_by = Tickers)

ret_ALSI_10 <- 
  T40_a %>% 
  
  filter(Tickers %in% unique(Capped_ALSI_10$Tickers) ) %>% 
  
  tbl_xts(cols_to_xts = Return, spread_by = Tickers)

wghts_ALSI_10[is.na(wghts_ALSI_10)] <- 0

ret_ALSI_10[is.na(ret_ALSI_10)] <- 0

ALSI_10_Idx <- 
  rmsfuns::Safe_Return.portfolio(R = ret_ALSI_10, weights = wghts_ALSI_10, lag_weights = T) |> 
  
  # Then I make it a tibble:
  xts_tbl() |>  
  
  rename(ALSI_10_Idx = portfolio.returns)

####For ALSI capped at 6%#####

wghts_ALSI_6 <- 
  Capped_ALSI_6 %>% 
  tbl_xts(cols_to_xts = weight, spread_by = Tickers)

ret_ALSI_6 <- 
  T40_a %>% 
  
  filter(Tickers %in% unique(Capped_ALSI_6$Tickers) ) %>% 
  
  tbl_xts(cols_to_xts = Return, spread_by = Tickers)

wghts_ALSI_6[is.na(wghts_ALSI_6)] <- 0

ret_ALSI_6[is.na(ret_ALSI_6)] <- 0

ALSI_6_Idx <- 
  rmsfuns::Safe_Return.portfolio(R = ret_ALSI_6, weights = wghts_ALSI_6, lag_weights = T) |> 
  
  # Then I make it a tibble:
  xts_tbl() |>  
  
  rename(ALSI_6_Idx = portfolio.returns)

####For SWIX capped at 10%#####

wghts_SWIX_10 <- 
  Capped_SWIX_10 %>% 
  tbl_xts(cols_to_xts = weight, spread_by = Tickers)

ret_SWIX_10 <- 
  T40_a %>% 
  
  filter(Tickers %in% unique(Capped_SWIX_10$Tickers) ) %>% 
  
  tbl_xts(cols_to_xts = Return, spread_by = Tickers)

wghts_SWIX_10[is.na(wghts_SWIX_10)] <- 0

ret_SWIX_10[is.na(ret_SWIX_10)] <- 0

SWIX_10_Idx <- 
  rmsfuns::Safe_Return.portfolio(R = ret_SWIX_10, weights = wghts_SWIX_10, lag_weights = T) |> 
  
  # Then I make it a tibble:
  xts_tbl() |>  
  
  rename(SWIX_10_Idx = portfolio.returns)



####For SWIX capped at 6%#####

wghts_SWIX_6 <- 
  Capped_SWIX_6 %>% 
  tbl_xts(cols_to_xts = weight, spread_by = Tickers)

ret_SWIX_6 <- 
  T40_a %>% 
  
  filter(Tickers %in% unique(Capped_SWIX_6$Tickers) ) %>% 
  
  tbl_xts(cols_to_xts = Return, spread_by = Tickers)

wghts_SWIX_6[is.na(wghts_SWIX_6)] <- 0

ret_SWIX_6[is.na(ret_SWIX_6)] <- 0

SWIX_6_Idx <- 
  rmsfuns::Safe_Return.portfolio(R = ret_SWIX_6, weights = wghts_SWIX_6, lag_weights = T) |> 
  
  # Then I make it a tibble:
  xts_tbl() |>  
  
  rename(SWIX_6_Idx = portfolio.returns)



```


```{r, Plot the capped indexes}

Capped_df_final <- ALSI_6_Idx |> inner_join(ALSI_10_Idx, by ="date") |> 
    inner_join(SWIX_6_Idx, by ="date") |> 
    inner_join(SWIX_10_Idx, by ="date") |>
    
    arrange(date) |> 
    mutate(across(.cols = -date, .fns = ~cumprod(1+.))) |> # cumulative returns
    mutate(across(.cols = -date, .fns = ~./first(.))) |>   # Start at 1
    inner_join(Cum_ret |> pivot_wider(names_from= "Index", values_from= "Cumret"), by = "date") |> # Add the uncapped cumret 
    
    rename("ALSI Capped 6%" = ALSI_6_Idx, "ALSI Capped 10%" = ALSI_10_Idx,"SWIX Capped 6%" =  SWIX_6_Idx, "SWIX Capped 10%" =  SWIX_10_Idx, "Uncapped SWIX" = SWIX, "Uncapped ALSI" = ALSI) |> # rename for clarity
    
    pivot_longer(cols = -date, names_to = "Description", values_to = "Values")

# And now, at last, for the plot

capping_plot_ALSI <- 

Capped_df_final |> filter(Description %in% c("ALSI Capped 6%", "ALSI Capped 10%", "Uncapped ALSI"))  |> 

    ggplot() + 
  
  geom_line(aes(date, Values , color = Description), size = 0.8, alpha = 0.7) +
  
   fmxdat::theme_fmx(title.size = fmxdat::ggpts(30), 
                    subtitle.size = fmxdat::ggpts(0),
                    caption.size = fmxdat::ggpts(25),
                    CustomCaption = T) + 
    
  fmxdat::fmx_cols() + 
  
  labs(x = "", y = "%", caption = "Note:\nCalculation own",
       title = "Cumulative Returns of ALSI and SWIX Indexes Capped at 6% and 10%",
       subtitle = "")

capping_plot_SWIX <- 

Capped_df_final |> filter(Description %in% c("SWIX Capped 6%", "SWIX Capped 10%", "Uncapped SWIX"))  |> 

    ggplot() + 
  
  geom_line(aes(date, Values , color = Description), size = 0.8, alpha = 0.7) +
  
   fmxdat::theme_fmx(title.size = fmxdat::ggpts(30), 
                    subtitle.size = fmxdat::ggpts(0),
                    caption.size = fmxdat::ggpts(25),
                    CustomCaption = T) + 
    
  fmxdat::fmx_cols() + 
  
  labs(x = "", y = "%", caption = "Note:\nCalculation own",
       title = "Cumulative Returns of ALSI and SWIX Indexes Capped at 6% and 10%",
       subtitle = "")

# Finplot for finishing touches:

fmxdat::finplot(capping_plot_ALSI, x.vert = T, x.date.type = "%Y", x.date.dist = "1 year", darkcol = T)

fmxdat::finplot(capping_plot_SWIX, x.vert = T, x.date.type = "%Y", x.date.dist = "1 year", darkcol = T)


```





